e = expression_data
#> feature information
f = data.frame(
label = rownames(expression_data),
No = seq(1:nrow(expression_data))
)
# functions ----------------------
RSD = function(data){
return(apply(data,1,function(x){
x = remove_outlier(x)[[1]]
return(sd(x,na.rm=T)/mean(x,na.rm=T))
}))
}
#> split e and p by different sample type.
#>
p_qc =
p %>%
filter(sampleType == 'qc')
p_sample =
p %>%
filter(sampleType == "sample")
p <- rbind(p_qc,p_sample)
index_qc = p_qc %>% pull(label)
index_sample = p_sample %>% pull(label)
e_qc = e %>% select(all_of(index_qc)) %>% as.matrix()
e_sample = e %>% select(all_of(index_sample)) %>% as.matrix()
e.df <- e %>% select(c(index_qc,index_sample))
e <- as.matrix(e.df)
#> orderd expression data as sample followed qc.
normalized_dataset = list(
none = e
)
#> corrlation of train sets and target sets
train = e_qc
target = e_sample
batch. = factor(p$batch,levels = unique(p$batch))
time. = p$time
sampleType. = p$sampleType
all = cbind(train,target)
normalized = rep(0,ncol(all))
normalized
all
batch_index = unique(batch.)
batch_index
batch_index = unique(batch.) %>% as.character()
batch_index = unique(batch.)
# data prepare -------------
#> messages...
msg_yes = green$bold$italic
msg_no = red$bold$italic
msg_warning = yellow$bold$italic
#> check data type
if (class(obj) != "mass_dataset"){
message(msg_no("Error: Only accept objects which generated by massdataset package."))
return()
}
#> sample infomation
#> If there is no batch effect information add A as batch.
p =
obj@sample_info %>%
dplyr::mutate(
label = sample_id,
time = injection.order,
sampleType = case_when(
class == QC_tag ~ "qc",
TRUE ~ "sample"
))
if('batch' %in% colnames(p)) {
p =
p %>%
select(label,time,sampleType,batch)
} else {
p =
p %>%
mutate(
batch = "A"
) %>%
select(label,time,sampleType,batch)
}
#> expression matrix.
expression_data = obj@expression_data %>% as.data.frame()
e = expression_data
#> feature information
f = data.frame(
label = rownames(expression_data),
No = seq(1:nrow(expression_data))
)
# functions ----------------------
RSD = function(data){
return(apply(data,1,function(x){
x = remove_outlier(x)[[1]]
return(sd(x,na.rm=T)/mean(x,na.rm=T))
}))
}
}
head(p)
#> correlation of each batch.
#> each batch must have at least two QC or sample.
p %>%
group_by(batch) %>%
summarise(num = n(sampleType))
#> correlation of each batch.
#> each batch must have at least two QC or sample.
p %>%
group_by(batch) %>%
summarise(num = n())
#> correlation of each batch.
#> each batch must have at least two QC or sample.
p %>%
group_by(batch,sampleType) %>%
summarise(num = n())
#> correlation of each batch.
#> each batch must have at least two QC or sample.
p$batch = rep(c(1,2,3),c(20,30,length(p$batch)-50))
p$batch
length(p$batch)/3
#> correlation of each batch.
#> each batch must have at least two QC or sample.
p$batch = rep(c(1,2,3),times = length(p$batch)/3)
p$batch
p %>%
group_by(batch,sampleType) %>%
summarise(num = n())
batch_check =
p %>%
group_by(batch,sampleType) %>%
summarise(num = n()) %>%
mutate(
check = case_when(
num < 2 ~ "no",
TRUE ~ "yes"
)
)
batch_check
message(msg_no("There are less than two member of QC or sample in one of your batch label, SERRF requires at least two QCs or Samples in each batch."))
message(msg_no(paste0(capture.output(batch_check),collapse = '\n')))
message(msg_warning(paste0(capture.output(batch_check),collapse = '\n')))
batch_check %>% kable
batch_check %>% kableExtra::kable()
message(msg_no("There are less than two member of QC or sample in one of your batch label, SERRF requires at least two QCs or Samples in each batch."))
message(msg_warning(paste0(capture.output(batch_check),collapse = '\n')))
bruceR::print_table(batch_check)
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check)),collapse = '\n')))
bruceR::print_table
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check,row.names = F)),collapse = '\n')))
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check,row.names = F,digits = 0)),collapse = '\n')))
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check,row.names = F,digits = 0,file.align.text = "center")),collapse = '\n')))
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check,row.names = F,digits = 0,title = 'Summary of sample number of each batch')),collapse = '\n')))
message(msg_no("There are less than two member of QC or sample in one of your batch label, SERRF requires at least two QCs or Samples in each batch."))
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check,row.names = F,digits = 0,title = 'Summary of sample number of each batch')),collapse = '\n')))
core_num = 8
future::plan("multisession",workers = core_num)
batch_index = unique(batch.)
batch_index
x = batch_index
p
.x = 1
p %>% filter(
batch == .x,
sampleType = 'qc'
) %>%
pull(label)
p %>% filter(
batch == .x,
sampleType == 'qc'
) %>%
pull(label)
label_index = p %>% filter(
batch == .x,
sampleType == 'qc'
) %>%
pull(label)
e_qc_batch = e %>% select(all_of(label_index))
e_qc_batch
e_qc_batch %>%
t() %>%
scale
xx = e_qc_batch %>%
t() %>%
scale
xx[1:5,1:5]
xx = e_qc_batch %>%
t() %>%
scale %>%
t()
xx[1:5,1:5]
y = 'sample'
label_index = p %>% filter(
batch == .x,
sampleType == y
) %>%
pull(label)
label_index
e_batch = e %>% select(all_of(label_index))
e_batch_scale = e_batch %>%
scale()
e_batch_scale[1:5,1:5]
corrs_fun <- function(x,y) {
p <- progressr::progressor(steps = length(x))
b = furrr::future_map(,x = x,.f = function(.x) {
Sys.sleep(0.05)
p()
label_index = p %>% filter(
batch == .x,
sampleType == y
) %>%
pull(label)
e_batch = e %>% select(all_of(label_index))
if(y == 'qc') {
e_batch_scale = e_batch %>%
t() %>%
scale %>%
cor(.,method = "spearman")
}
if(y == 'sample') {
e_batch_scale = e_batch %>%
scale() %>%
t() %>%
cor(.,method = "spearman")
}
return(e_batch_scale)
})
return(b)
}
library(progressr)
batch_index = unique(batch.)
x = batch_index
future::plan("multisession",workers = core_num)
message(msg_yes("correlation of train sets."))
with_progress({
corrs_train = corrs_fun(x = batch_index,y = 'qc')
})
corrs_fun <- function(x,y) {
p <- progressr::progressor(steps = length(x))
b = furrr::future_map(,.x = x,.f = function(.x) {
Sys.sleep(0.05)
p()
label_index = p %>% filter(
batch == .x,
sampleType == y
) %>%
pull(label)
e_batch = e %>% select(all_of(label_index))
if(y == 'qc') {
e_batch_scale = e_batch %>%
t() %>%
scale %>%
cor(.,method = "spearman")
}
if(y == 'sample') {
e_batch_scale = e_batch %>%
scale() %>%
t() %>%
cor(.,method = "spearman")
}
return(e_batch_scale)
})
return(b)
}
with_progress({
corrs_train = corrs_fun(x = batch_index,y = 'qc')
})
with_progress({
corrs_train = corrs_fun(.x = batch_index,y = 'qc')
})
x = batch_index
y = 'qc'
label_index = p %>% filter(
batch == .x,
sampleType == y
) %>%
pull(label)
e_batch = e %>% select(all_of(label_index))
if(y == 'qc') {
e_batch_scale = e_batch %>%
t() %>%
scale %>%
cor(.,method = "spearman")
}
if(y == 'sample') {
e_batch_scale = e_batch %>%
scale() %>%
t() %>%
cor(.,method = "spearman")
}
return(e_batch_scale)
e_batch_scale
e_batch_scale[1:5,1:5]
corrs_fun(x = batch_index,y = 'sample')
corrs_fun <- function(x,y) {
p <- progressr::progressor(steps = length(x))
b = furrr::future_map(.x = x,.f = function(.x) {
Sys.sleep(0.05)
p()
label_index = p %>% filter(
batch == .x,
sampleType == y
) %>%
pull(label)
e_batch = e %>% select(all_of(label_index))
if(y == 'qc') {
e_batch_scale = e_batch %>%
t() %>%
scale %>%
cor(.,method = "spearman")
}
if(y == 'sample') {
e_batch_scale = e_batch %>%
scale() %>%
t() %>%
cor(.,method = "spearman")
}
return(e_batch_scale)
})
return(b)
}
with_progress({
corrs_train = corrs_fun(x = batch_index,y = 'qc')
})
corrs_fun <- function(x,y) {
p <- progressr::progressor(steps = length(x))
b = furrr::future_map(.x = x,.f = function(.x) {
Sys.sleep(0.05)
p()
label_index = p %>% dplyr::filter(
batch == .x,
sampleType == y
) %>%
pull(label)
e_batch = e %>% select(all_of(label_index))
if(y == 'qc') {
e_batch_scale = e_batch %>%
t() %>%
scale %>%
cor(.,method = "spearman")
}
if(y == 'sample') {
e_batch_scale = e_batch %>%
scale() %>%
t() %>%
cor(.,method = "spearman")
}
return(e_batch_scale)
})
return(b)
}
with_progress({
corrs_train = corrs_fun(x = batch_index,y = 'qc')
})
#> sample infomation
#> If there is no batch effect information add A as batch.
p =
obj@sample_info %>%
dplyr::mutate(
label = sample_id,
time = injection.order,
sampleType = case_when(
class == QC_tag ~ "qc",
TRUE ~ "sample"
))
if('batch' %in% colnames(p)) {
p =
p %>%
select(label,time,sampleType,batch)
} else {
p =
p %>%
mutate(
batch = "A"
) %>%
select(label,time,sampleType,batch)
}
#> expression matrix.
expression_data = obj@expression_data %>% as.data.frame()
corrs_fun <- function(x,y) {
pp <- progressr::progressor(steps = length(x))
b = furrr::future_map(.x = x,.f = function(.x) {
Sys.sleep(0.05)
pp()
label_index = p %>% dplyr::filter(
batch == .x,
sampleType == y
) %>%
pull(label)
e_batch = e %>% select(all_of(label_index))
if(y == 'qc') {
e_batch_scale = e_batch %>%
t() %>%
scale %>%
cor(.,method = "spearman")
}
if(y == 'sample') {
e_batch_scale = e_batch %>%
scale() %>%
t() %>%
cor(.,method = "spearman")
}
return(e_batch_scale)
})
return(b)
}
with_progress({
corrs_train = corrs_fun(x = batch_index,y = 'qc')
})
x = batch_index
length(batch_index)
batch_index
#> correlation of each batch.
#> each batch must have at least two QC or sample.
p$batch = rep(c(1,2,3),times = length(p$batch)/3)
batch_check =
p %>%
group_by(batch,sampleType) %>%
summarise(num = n()) %>%
mutate(
check = case_when(
num == 1 ~ "no",
TRUE ~ "yes"
)
)
batch_check =
p %>%
group_by(batch,sampleType) %>%
summarise(num = n(),.groups = 'batch') %>%
mutate(
check = case_when(
num == 1 ~ "no",
TRUE ~ "yes"
)
)
batch_check =
p %>%
group_by(batch,sampleType) %>%
summarise(num = n(),.groups = batch) %>%
mutate(
check = case_when(
num == 1 ~ "no",
TRUE ~ "yes"
)
)
batch_check =
p %>%
group_by(batch,sampleType) %>%
summarise(num = n()) %>%
mutate(
check = case_when(
num == 1 ~ "no",
TRUE ~ "yes"
)
)
batch_check
if('no'%in%batch_check$check ) {
message(msg_no("Error: Each batch contains at least two QC or two samples, Check the following tables."))
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check,row.names = F,digits = 0,title = 'Summary of sample number of each batch')),collapse = '\n')))
return()
} else {
batch_index = unique(batch.)
x = batch_index
future::plan("multisession",workers = core_num)
message(msg_yes("correlation of train sets."))
with_progress({
corrs_train = corrs_fun(x = batch_index,y = 'qc')
})
with_progress({
corrs_target = corrs_fun(x = batch_index,y = 'sample')
})
})
if('no'%in%batch_check$check ) {
message(msg_no("Error: Each batch contains at least two QC or two samples, Check the following tables."))
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check,row.names = F,digits = 0,title = 'Summary of sample number of each batch')),collapse = '\n')))
return()
} else {
batch_index = unique(batch.)
x = batch_index
future::plan("multisession",workers = core_num)
message(msg_yes("correlation of train sets."))
with_progress({
corrs_train = corrs_fun(x = batch_index,y = 'qc')
})
with_progress({
corrs_target = corrs_fun(x = batch_index,y = 'sample')
})
}
message(msg_yes("correlation of target sets."))
corrs_train
corrs_train[[1]]
corrs_train[[1]][1:5,1:5]
corrs_train[[2]][1:5,1:5]
batch_index
batch_index = unique(p$batch)
x = batch_index
batch_index
if('no'%in%batch_check$check ) {
message(msg_no("Error: Each batch contains at least two QC or two samples, Check the following tables."))
message(msg_warning(paste0(capture.output(bruceR::print_table(batch_check,row.names = F,digits = 0,title = 'Summary of sample number of each batch')),collapse = '\n')))
return()
} else {
batch_index = unique(p$batch)
future::plan("multisession",workers = core_num)
message(msg_yes("correlation of train sets."))
with_progress({
corrs_train = corrs_fun(x = batch_index,y = 'qc')
})
message(msg_yes("correlation of target sets."))
with_progress({
corrs_target = corrs_fun(x = batch_index,y = 'sample')
})
}
corrs_target[[1]][1:5,1:5]
corrs_target[[2]][1:5,1:5]
corrs_target[[3]][1:5,1:5]
corrs_train[[1]][1:5,1:5]
